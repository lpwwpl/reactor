// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_protocol_2eproto__INCLUDED
#define PROTOBUF_protocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
class BaseMessage;
class BaseMessageDefaultTypeInternal;
extern BaseMessageDefaultTypeInternal _BaseMessage_default_instance_;
class _base_;
class _base_DefaultTypeInternal;
extern _base_DefaultTypeInternal __base__default_instance_;
class _data_;
class _data_DefaultTypeInternal;
extern _data_DefaultTypeInternal __data__default_instance_;
class _infor_;
class _infor_DefaultTypeInternal;
extern _infor_DefaultTypeInternal __infor__default_instance_;
class _test_;
class _test_DefaultTypeInternal;
extern _test_DefaultTypeInternal __test__default_instance_;

namespace protobuf_protocol_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_protocol_2eproto

enum _data__Type {
  _data__Type_INFOR = 1,
  _data__Type_RET = 2
};
bool _data__Type_IsValid(int value);
const _data__Type _data__Type_Type_MIN = _data__Type_INFOR;
const _data__Type _data__Type_Type_MAX = _data__Type_RET;
const int _data__Type_Type_ARRAYSIZE = _data__Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* _data__Type_descriptor();
inline const ::std::string& _data__Type_Name(_data__Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    _data__Type_descriptor(), value);
}
inline bool _data__Type_Parse(
    const ::std::string& name, _data__Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<_data__Type>(
    _data__Type_descriptor(), name, value);
}
// ===================================================================

class _base_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:_base_) */ {
 public:
  _base_();
  virtual ~_base_();

  _base_(const _base_& from);

  inline _base_& operator=(const _base_& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const _base_& default_instance();

  static inline const _base_* internal_default_instance() {
    return reinterpret_cast<const _base_*>(
               &__base__default_instance_);
  }

  void Swap(_base_* other);

  // implements Message ----------------------------------------------

  inline _base_* New() const PROTOBUF_FINAL { return New(NULL); }

  _base_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const _base_& from);
  void MergeFrom(const _base_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(_base_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 opcode = 1;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 1;
  ::google::protobuf::int32 opcode() const;
  void set_opcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:_base_)
 private:
  void set_has_opcode();
  void clear_has_opcode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 opcode_;
  friend struct  protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BaseMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseMessage) */ {
 public:
  BaseMessage();
  virtual ~BaseMessage();

  BaseMessage(const BaseMessage& from);

  inline BaseMessage& operator=(const BaseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseMessage& default_instance();

  static inline const BaseMessage* internal_default_instance() {
    return reinterpret_cast<const BaseMessage*>(
               &_BaseMessage_default_instance_);
  }

  void Swap(BaseMessage* other);

  // implements Message ----------------------------------------------

  inline BaseMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  BaseMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BaseMessage& from);
  void MergeFrom(const BaseMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BaseMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required ._base_ msgbase = 1;
  bool has_msgbase() const;
  void clear_msgbase();
  static const int kMsgbaseFieldNumber = 1;
  const ::_base_& msgbase() const;
  ::_base_* mutable_msgbase();
  ::_base_* release_msgbase();
  void set_allocated_msgbase(::_base_* msgbase);

  // @@protoc_insertion_point(class_scope:BaseMessage)
 private:
  void set_has_msgbase();
  void clear_has_msgbase();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::_base_* msgbase_;
  friend struct  protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class _test_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:_test_) */ {
 public:
  _test_();
  virtual ~_test_();

  _test_(const _test_& from);

  inline _test_& operator=(const _test_& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const _test_& default_instance();

  static inline const _test_* internal_default_instance() {
    return reinterpret_cast<const _test_*>(
               &__test__default_instance_);
  }

  void Swap(_test_* other);

  // implements Message ----------------------------------------------

  inline _test_* New() const PROTOBUF_FINAL { return New(NULL); }

  _test_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const _test_& from);
  void MergeFrom(const _test_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(_test_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string echoStr = 2;
  bool has_echostr() const;
  void clear_echostr();
  static const int kEchoStrFieldNumber = 2;
  const ::std::string& echostr() const;
  void set_echostr(const ::std::string& value);
  #if LANG_CXX11
  void set_echostr(::std::string&& value);
  #endif
  void set_echostr(const char* value);
  void set_echostr(const char* value, size_t size);
  ::std::string* mutable_echostr();
  ::std::string* release_echostr();
  void set_allocated_echostr(::std::string* echostr);

  // required ._base_ msgbase = 1;
  bool has_msgbase() const;
  void clear_msgbase();
  static const int kMsgbaseFieldNumber = 1;
  const ::_base_& msgbase() const;
  ::_base_* mutable_msgbase();
  ::_base_* release_msgbase();
  void set_allocated_msgbase(::_base_* msgbase);

  // @@protoc_insertion_point(class_scope:_test_)
 private:
  void set_has_msgbase();
  void clear_has_msgbase();
  void set_has_echostr();
  void clear_has_echostr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr echostr_;
  ::_base_* msgbase_;
  friend struct  protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class _infor_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:_infor_) */ {
 public:
  _infor_();
  virtual ~_infor_();

  _infor_(const _infor_& from);

  inline _infor_& operator=(const _infor_& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const _infor_& default_instance();

  static inline const _infor_* internal_default_instance() {
    return reinterpret_cast<const _infor_*>(
               &__infor__default_instance_);
  }

  void Swap(_infor_* other);

  // implements Message ----------------------------------------------

  inline _infor_* New() const PROTOBUF_FINAL { return New(NULL); }

  _infor_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const _infor_& from);
  void MergeFrom(const _infor_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(_infor_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string sex = 3;
  bool has_sex() const;
  void clear_sex();
  static const int kSexFieldNumber = 3;
  const ::std::string& sex() const;
  void set_sex(const ::std::string& value);
  #if LANG_CXX11
  void set_sex(::std::string&& value);
  #endif
  void set_sex(const char* value);
  void set_sex(const char* value, size_t size);
  ::std::string* mutable_sex();
  ::std::string* release_sex();
  void set_allocated_sex(::std::string* sex);

  // optional string num = 4;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 4;
  const ::std::string& num() const;
  void set_num(const ::std::string& value);
  #if LANG_CXX11
  void set_num(::std::string&& value);
  #endif
  void set_num(const char* value);
  void set_num(const char* value, size_t size);
  ::std::string* mutable_num();
  ::std::string* release_num();
  void set_allocated_num(::std::string* num);

  // optional string date = 5;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 5;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // @@protoc_insertion_point(class_scope:_infor_)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_sex();
  void clear_has_sex();
  void set_has_num();
  void clear_has_num();
  void set_has_date();
  void clear_has_date();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr sex_;
  ::google::protobuf::internal::ArenaStringPtr num_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  friend struct  protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class _data_ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:_data_) */ {
 public:
  _data_();
  virtual ~_data_();

  _data_(const _data_& from);

  inline _data_& operator=(const _data_& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const _data_& default_instance();

  static inline const _data_* internal_default_instance() {
    return reinterpret_cast<const _data_*>(
               &__data__default_instance_);
  }

  void Swap(_data_* other);

  // implements Message ----------------------------------------------

  inline _data_* New() const PROTOBUF_FINAL { return New(NULL); }

  _data_* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const _data_& from);
  void MergeFrom(const _data_& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(_data_* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef _data__Type Type;
  static const Type INFOR =
    _data__Type_INFOR;
  static const Type RET =
    _data__Type_RET;
  static inline bool Type_IsValid(int value) {
    return _data__Type_IsValid(value);
  }
  static const Type Type_MIN =
    _data__Type_Type_MIN;
  static const Type Type_MAX =
    _data__Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    _data__Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return _data__Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return _data__Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return _data__Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string ret = 5;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 5;
  const ::std::string& ret() const;
  void set_ret(const ::std::string& value);
  #if LANG_CXX11
  void set_ret(::std::string&& value);
  #endif
  void set_ret(const char* value);
  void set_ret(const char* value, size_t size);
  ::std::string* mutable_ret();
  ::std::string* release_ret();
  void set_allocated_ret(::std::string* ret);

  // required ._base_ msgbase = 1;
  bool has_msgbase() const;
  void clear_msgbase();
  static const int kMsgbaseFieldNumber = 1;
  const ::_base_& msgbase() const;
  ::_base_* mutable_msgbase();
  ::_base_* release_msgbase();
  void set_allocated_msgbase(::_base_* msgbase);

  // optional ._infor_ infor = 4;
  bool has_infor() const;
  void clear_infor();
  static const int kInforFieldNumber = 4;
  const ::_infor_& infor() const;
  ::_infor_* mutable_infor();
  ::_infor_* release_infor();
  void set_allocated_infor(::_infor_* infor);

  // required int32 flag = 2;
  bool has_flag() const;
  void clear_flag();
  static const int kFlagFieldNumber = 2;
  ::google::protobuf::int32 flag() const;
  void set_flag(::google::protobuf::int32 value);

  // optional ._data_.Type type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::_data__Type type() const;
  void set_type(::_data__Type value);

  // @@protoc_insertion_point(class_scope:_data_)
 private:
  void set_has_msgbase();
  void clear_has_msgbase();
  void set_has_flag();
  void clear_has_flag();
  void set_has_type();
  void clear_has_type();
  void set_has_infor();
  void clear_has_infor();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ret_;
  ::_base_* msgbase_;
  ::_infor_* infor_;
  ::google::protobuf::int32 flag_;
  int type_;
  friend struct  protobuf_protocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// _base_

// required int32 opcode = 1;
inline bool _base_::has_opcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void _base_::set_has_opcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void _base_::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void _base_::clear_opcode() {
  opcode_ = 0;
  clear_has_opcode();
}
inline ::google::protobuf::int32 _base_::opcode() const {
  // @@protoc_insertion_point(field_get:_base_.opcode)
  return opcode_;
}
inline void _base_::set_opcode(::google::protobuf::int32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:_base_.opcode)
}

// -------------------------------------------------------------------

// BaseMessage

// required ._base_ msgbase = 1;
inline bool BaseMessage::has_msgbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseMessage::set_has_msgbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseMessage::clear_has_msgbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseMessage::clear_msgbase() {
  if (msgbase_ != NULL) msgbase_->::_base_::Clear();
  clear_has_msgbase();
}
inline const ::_base_& BaseMessage::msgbase() const {
  // @@protoc_insertion_point(field_get:BaseMessage.msgbase)
  return msgbase_ != NULL ? *msgbase_
                         : *::_base_::internal_default_instance();
}
inline ::_base_* BaseMessage::mutable_msgbase() {
  set_has_msgbase();
  if (msgbase_ == NULL) {
    msgbase_ = new ::_base_;
  }
  // @@protoc_insertion_point(field_mutable:BaseMessage.msgbase)
  return msgbase_;
}
inline ::_base_* BaseMessage::release_msgbase() {
  // @@protoc_insertion_point(field_release:BaseMessage.msgbase)
  clear_has_msgbase();
  ::_base_* temp = msgbase_;
  msgbase_ = NULL;
  return temp;
}
inline void BaseMessage::set_allocated_msgbase(::_base_* msgbase) {
  delete msgbase_;
  msgbase_ = msgbase;
  if (msgbase) {
    set_has_msgbase();
  } else {
    clear_has_msgbase();
  }
  // @@protoc_insertion_point(field_set_allocated:BaseMessage.msgbase)
}

// -------------------------------------------------------------------

// _test_

// required ._base_ msgbase = 1;
inline bool _test_::has_msgbase() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void _test_::set_has_msgbase() {
  _has_bits_[0] |= 0x00000002u;
}
inline void _test_::clear_has_msgbase() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void _test_::clear_msgbase() {
  if (msgbase_ != NULL) msgbase_->::_base_::Clear();
  clear_has_msgbase();
}
inline const ::_base_& _test_::msgbase() const {
  // @@protoc_insertion_point(field_get:_test_.msgbase)
  return msgbase_ != NULL ? *msgbase_
                         : *::_base_::internal_default_instance();
}
inline ::_base_* _test_::mutable_msgbase() {
  set_has_msgbase();
  if (msgbase_ == NULL) {
    msgbase_ = new ::_base_;
  }
  // @@protoc_insertion_point(field_mutable:_test_.msgbase)
  return msgbase_;
}
inline ::_base_* _test_::release_msgbase() {
  // @@protoc_insertion_point(field_release:_test_.msgbase)
  clear_has_msgbase();
  ::_base_* temp = msgbase_;
  msgbase_ = NULL;
  return temp;
}
inline void _test_::set_allocated_msgbase(::_base_* msgbase) {
  delete msgbase_;
  msgbase_ = msgbase;
  if (msgbase) {
    set_has_msgbase();
  } else {
    clear_has_msgbase();
  }
  // @@protoc_insertion_point(field_set_allocated:_test_.msgbase)
}

// optional string echoStr = 2;
inline bool _test_::has_echostr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void _test_::set_has_echostr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void _test_::clear_has_echostr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void _test_::clear_echostr() {
  echostr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_echostr();
}
inline const ::std::string& _test_::echostr() const {
  // @@protoc_insertion_point(field_get:_test_.echoStr)
  return echostr_.GetNoArena();
}
inline void _test_::set_echostr(const ::std::string& value) {
  set_has_echostr();
  echostr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:_test_.echoStr)
}
#if LANG_CXX11
inline void _test_::set_echostr(::std::string&& value) {
  set_has_echostr();
  echostr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:_test_.echoStr)
}
#endif
inline void _test_::set_echostr(const char* value) {
  set_has_echostr();
  echostr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:_test_.echoStr)
}
inline void _test_::set_echostr(const char* value, size_t size) {
  set_has_echostr();
  echostr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:_test_.echoStr)
}
inline ::std::string* _test_::mutable_echostr() {
  set_has_echostr();
  // @@protoc_insertion_point(field_mutable:_test_.echoStr)
  return echostr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* _test_::release_echostr() {
  // @@protoc_insertion_point(field_release:_test_.echoStr)
  clear_has_echostr();
  return echostr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void _test_::set_allocated_echostr(::std::string* echostr) {
  if (echostr != NULL) {
    set_has_echostr();
  } else {
    clear_has_echostr();
  }
  echostr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), echostr);
  // @@protoc_insertion_point(field_set_allocated:_test_.echoStr)
}

// -------------------------------------------------------------------

// _infor_

// required string id = 1;
inline bool _infor_::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void _infor_::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void _infor_::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void _infor_::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& _infor_::id() const {
  // @@protoc_insertion_point(field_get:_infor_.id)
  return id_.GetNoArena();
}
inline void _infor_::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:_infor_.id)
}
#if LANG_CXX11
inline void _infor_::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:_infor_.id)
}
#endif
inline void _infor_::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:_infor_.id)
}
inline void _infor_::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:_infor_.id)
}
inline ::std::string* _infor_::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:_infor_.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* _infor_::release_id() {
  // @@protoc_insertion_point(field_release:_infor_.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void _infor_::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:_infor_.id)
}

// optional string name = 2;
inline bool _infor_::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void _infor_::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void _infor_::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void _infor_::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& _infor_::name() const {
  // @@protoc_insertion_point(field_get:_infor_.name)
  return name_.GetNoArena();
}
inline void _infor_::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:_infor_.name)
}
#if LANG_CXX11
inline void _infor_::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:_infor_.name)
}
#endif
inline void _infor_::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:_infor_.name)
}
inline void _infor_::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:_infor_.name)
}
inline ::std::string* _infor_::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:_infor_.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* _infor_::release_name() {
  // @@protoc_insertion_point(field_release:_infor_.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void _infor_::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:_infor_.name)
}

// optional string sex = 3;
inline bool _infor_::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void _infor_::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void _infor_::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void _infor_::clear_sex() {
  sex_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sex();
}
inline const ::std::string& _infor_::sex() const {
  // @@protoc_insertion_point(field_get:_infor_.sex)
  return sex_.GetNoArena();
}
inline void _infor_::set_sex(const ::std::string& value) {
  set_has_sex();
  sex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:_infor_.sex)
}
#if LANG_CXX11
inline void _infor_::set_sex(::std::string&& value) {
  set_has_sex();
  sex_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:_infor_.sex)
}
#endif
inline void _infor_::set_sex(const char* value) {
  set_has_sex();
  sex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:_infor_.sex)
}
inline void _infor_::set_sex(const char* value, size_t size) {
  set_has_sex();
  sex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:_infor_.sex)
}
inline ::std::string* _infor_::mutable_sex() {
  set_has_sex();
  // @@protoc_insertion_point(field_mutable:_infor_.sex)
  return sex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* _infor_::release_sex() {
  // @@protoc_insertion_point(field_release:_infor_.sex)
  clear_has_sex();
  return sex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void _infor_::set_allocated_sex(::std::string* sex) {
  if (sex != NULL) {
    set_has_sex();
  } else {
    clear_has_sex();
  }
  sex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sex);
  // @@protoc_insertion_point(field_set_allocated:_infor_.sex)
}

// optional string num = 4;
inline bool _infor_::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void _infor_::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void _infor_::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void _infor_::clear_num() {
  num_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_num();
}
inline const ::std::string& _infor_::num() const {
  // @@protoc_insertion_point(field_get:_infor_.num)
  return num_.GetNoArena();
}
inline void _infor_::set_num(const ::std::string& value) {
  set_has_num();
  num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:_infor_.num)
}
#if LANG_CXX11
inline void _infor_::set_num(::std::string&& value) {
  set_has_num();
  num_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:_infor_.num)
}
#endif
inline void _infor_::set_num(const char* value) {
  set_has_num();
  num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:_infor_.num)
}
inline void _infor_::set_num(const char* value, size_t size) {
  set_has_num();
  num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:_infor_.num)
}
inline ::std::string* _infor_::mutable_num() {
  set_has_num();
  // @@protoc_insertion_point(field_mutable:_infor_.num)
  return num_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* _infor_::release_num() {
  // @@protoc_insertion_point(field_release:_infor_.num)
  clear_has_num();
  return num_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void _infor_::set_allocated_num(::std::string* num) {
  if (num != NULL) {
    set_has_num();
  } else {
    clear_has_num();
  }
  num_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), num);
  // @@protoc_insertion_point(field_set_allocated:_infor_.num)
}

// optional string date = 5;
inline bool _infor_::has_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void _infor_::set_has_date() {
  _has_bits_[0] |= 0x00000010u;
}
inline void _infor_::clear_has_date() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void _infor_::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date();
}
inline const ::std::string& _infor_::date() const {
  // @@protoc_insertion_point(field_get:_infor_.date)
  return date_.GetNoArena();
}
inline void _infor_::set_date(const ::std::string& value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:_infor_.date)
}
#if LANG_CXX11
inline void _infor_::set_date(::std::string&& value) {
  set_has_date();
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:_infor_.date)
}
#endif
inline void _infor_::set_date(const char* value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:_infor_.date)
}
inline void _infor_::set_date(const char* value, size_t size) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:_infor_.date)
}
inline ::std::string* _infor_::mutable_date() {
  set_has_date();
  // @@protoc_insertion_point(field_mutable:_infor_.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* _infor_::release_date() {
  // @@protoc_insertion_point(field_release:_infor_.date)
  clear_has_date();
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void _infor_::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    set_has_date();
  } else {
    clear_has_date();
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:_infor_.date)
}

// -------------------------------------------------------------------

// _data_

// required ._base_ msgbase = 1;
inline bool _data_::has_msgbase() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void _data_::set_has_msgbase() {
  _has_bits_[0] |= 0x00000002u;
}
inline void _data_::clear_has_msgbase() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void _data_::clear_msgbase() {
  if (msgbase_ != NULL) msgbase_->::_base_::Clear();
  clear_has_msgbase();
}
inline const ::_base_& _data_::msgbase() const {
  // @@protoc_insertion_point(field_get:_data_.msgbase)
  return msgbase_ != NULL ? *msgbase_
                         : *::_base_::internal_default_instance();
}
inline ::_base_* _data_::mutable_msgbase() {
  set_has_msgbase();
  if (msgbase_ == NULL) {
    msgbase_ = new ::_base_;
  }
  // @@protoc_insertion_point(field_mutable:_data_.msgbase)
  return msgbase_;
}
inline ::_base_* _data_::release_msgbase() {
  // @@protoc_insertion_point(field_release:_data_.msgbase)
  clear_has_msgbase();
  ::_base_* temp = msgbase_;
  msgbase_ = NULL;
  return temp;
}
inline void _data_::set_allocated_msgbase(::_base_* msgbase) {
  delete msgbase_;
  msgbase_ = msgbase;
  if (msgbase) {
    set_has_msgbase();
  } else {
    clear_has_msgbase();
  }
  // @@protoc_insertion_point(field_set_allocated:_data_.msgbase)
}

// required int32 flag = 2;
inline bool _data_::has_flag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void _data_::set_has_flag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void _data_::clear_has_flag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void _data_::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 _data_::flag() const {
  // @@protoc_insertion_point(field_get:_data_.flag)
  return flag_;
}
inline void _data_::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:_data_.flag)
}

// optional ._data_.Type type = 3;
inline bool _data_::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void _data_::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void _data_::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void _data_::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::_data__Type _data_::type() const {
  // @@protoc_insertion_point(field_get:_data_.type)
  return static_cast< ::_data__Type >(type_);
}
inline void _data_::set_type(::_data__Type value) {
  assert(::_data__Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:_data_.type)
}

// optional ._infor_ infor = 4;
inline bool _data_::has_infor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void _data_::set_has_infor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void _data_::clear_has_infor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void _data_::clear_infor() {
  if (infor_ != NULL) infor_->::_infor_::Clear();
  clear_has_infor();
}
inline const ::_infor_& _data_::infor() const {
  // @@protoc_insertion_point(field_get:_data_.infor)
  return infor_ != NULL ? *infor_
                         : *::_infor_::internal_default_instance();
}
inline ::_infor_* _data_::mutable_infor() {
  set_has_infor();
  if (infor_ == NULL) {
    infor_ = new ::_infor_;
  }
  // @@protoc_insertion_point(field_mutable:_data_.infor)
  return infor_;
}
inline ::_infor_* _data_::release_infor() {
  // @@protoc_insertion_point(field_release:_data_.infor)
  clear_has_infor();
  ::_infor_* temp = infor_;
  infor_ = NULL;
  return temp;
}
inline void _data_::set_allocated_infor(::_infor_* infor) {
  delete infor_;
  infor_ = infor;
  if (infor) {
    set_has_infor();
  } else {
    clear_has_infor();
  }
  // @@protoc_insertion_point(field_set_allocated:_data_.infor)
}

// optional string ret = 5;
inline bool _data_::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void _data_::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void _data_::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void _data_::clear_ret() {
  ret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ret();
}
inline const ::std::string& _data_::ret() const {
  // @@protoc_insertion_point(field_get:_data_.ret)
  return ret_.GetNoArena();
}
inline void _data_::set_ret(const ::std::string& value) {
  set_has_ret();
  ret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:_data_.ret)
}
#if LANG_CXX11
inline void _data_::set_ret(::std::string&& value) {
  set_has_ret();
  ret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:_data_.ret)
}
#endif
inline void _data_::set_ret(const char* value) {
  set_has_ret();
  ret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:_data_.ret)
}
inline void _data_::set_ret(const char* value, size_t size) {
  set_has_ret();
  ret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:_data_.ret)
}
inline ::std::string* _data_::mutable_ret() {
  set_has_ret();
  // @@protoc_insertion_point(field_mutable:_data_.ret)
  return ret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* _data_::release_ret() {
  // @@protoc_insertion_point(field_release:_data_.ret)
  clear_has_ret();
  return ret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void _data_::set_allocated_ret(::std::string* ret) {
  if (ret != NULL) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
  ret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ret);
  // @@protoc_insertion_point(field_set_allocated:_data_.ret)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::_data__Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::_data__Type>() {
  return ::_data__Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocol_2eproto__INCLUDED
